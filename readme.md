В приведенном примере кода реализован паттерн "Наблюдатель" с использованием трех основных классов: Subject, ObserverBase и Observer.



1. Класс Subject

    Описание: Этот класс представляет собой субъект, который хранит состояние и список наблюдателей.

    Методы:
        __init__(): Инициализирует пустое состояние _data и пустое множество _observers.

    attach(observer): Добавляет наблюдателя в список. Проверяет, что переданный объект является экземпляром класса ObserverBase.

    detach(observer): Удаляет наблюдателя из списка.

    get_data(): Возвращает текущее состояние _data.

    set_data(data): Устанавливает новое значение состояния _data и вызывает метод notify(data) для уведомления наблюдателей.

    notify(data): Уведомляет всех подписанных наблюдателей об изменении состояния, вызывая их метод update(data).

2. Класс ObserverBase

    Описание: Абстрактный класс для наблюдателей, определяющий интерфейс.

    Методы:
        update(data): Абстрактный метод, который должен быть реализован в подклассах. Он будет вызываться для уведомления наблюдателя о новых данных.

3. Класс Observer

    Описание: Конкретная реализация наблюдателя, которая реагирует на изменения состояния субъекта.

    Методы:
        __init__(name): Инициализирует имя наблюдателя.

    update(data): Реализует метод уведомления. Принимает данные от субъекта и выводит их на экран с указанием имени наблюдателя.

Взаимодействие классов

Создание объектов:
        Создается экземпляр класса Subject, который будет отслеживать изменения.
        Создаются два экземпляра класса Observer, каждый с уникальным именем.

Подписка на события:
        Наблюдатели подписываются на события субъекта с помощью метода attach(). Теперь они будут получать уведомления об изменениях состояния.

Изменение состояния:
        Метод set_data(data) класса Subject вызывается для изменения состояния. Когда это происходит, субъект вызывает метод notify(data), который проходит по всем подписанным наблюдателям.
        
Уведомление наблюдателей:
        Каждый подписанный наблюдатель получает вызов своего метода update(data), где он может обработать новые данные (в данном случае просто вывести их на экран).
